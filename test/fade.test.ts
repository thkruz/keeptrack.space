import { KeepTrack } from '@app/keeptrack';
import { fadeIn, fadeOut } from '../src/engine/utils/fade';
// Generated by CodiumAI

/*
 *Code Analysis
 *
 *Objective:
 *The objective of the 'fadeIn' function is to animate the fading in of an HTML element by changing its display property and applying a transition effect.
 *
 *Inputs:
 *- el: an HTML element to be faded in
 *- type (optional): a string representing the display property value to be set after the fade-in animation (default is 'block')
 *- duration (optional): a number representing the duration of the fade-in animation in milliseconds (default is 1000)
 *- callback (optional): a function to be executed after the fade-in animation is completed
 *
 *Flow:
 *1. Check if the input element is null, if so, return
 *2. Set the display property value to the input type if it is not already set to that value
 *3. Set the transition property to apply the fade-in animation effect
 *4. Set a timeout to remove the transition effect and execute the callback function (if provided) after the duration of the animation
 *
 *Outputs:
 *- None (the function does not return any value)
 *
 *Additional aspects:
 *- The function uses the nullish coalescing operator (??=) to set default values for the type and duration inputs
 *- The function throws an error if the input element is null (TODO: implement this feature)
 *- The function removes the transition effect after the animation is completed to avoid interfering with other CSS transitions on the element
 */

describe('fadeIn_function', () => {
  // Tests that the function does not throw an error when the element is not null
  it('test_element_not_null', () => {
    const el = document.createElement('div');
    const spy = jest.fn();

    fadeIn(el, 'block', 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(el.style.display).toBe('block');
    expect(spy).toHaveBeenCalled();
  });

  // Tests that the function throws an error when the element is null
  it('test_element_null', () => {
    expect(() => {
      fadeIn(null);
    }).not.toThrow();
  });

  // Tests that the element fades in when it is hidden
  it('test_element_hidden_fade_in', () => {
    const el = document.createElement('div');
    const spy = jest.fn();

    fadeIn(el, 'block', 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(el.style.display).toBe('block');
    expect(spy).toHaveBeenCalled();
  });

  // Tests that the element does not fade in when it is already visible
  it('test_element_already_visible', () => {
    const el = document.createElement('div');

    el.style.display = 'block';
    const spy = jest.fn();

    fadeIn(el, 'block', 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(spy).not.toHaveBeenCalled();
  });

  // Tests that the function defaults to a duration of 1000ms when duration is not provided
  it('test_duration_not_provided', () => {
    const el = document.createElement('div');
    const spy = jest.fn();

    fadeIn(el, 'block', null, spy);
    jest.advanceTimersByTime(999);
    expect(spy).not.toHaveBeenCalled();
    jest.advanceTimersByTime(1);
    expect(spy).toHaveBeenCalled();
  });

  // Tests that the callback function is optional and can be provided
  it('test_callback_function_optional', () => {
    const el = document.createElement('div');
    const spy = jest.fn();

    fadeIn(el, 'block', 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(el.style.display).toBe('block');
    expect(spy).toHaveBeenCalled();
  });
});

// Generated by CodiumAI

/*
 *Code Analysis
 *
 *Objective:
 *The objective of the 'fadeOut' function is to gradually fade out an HTML element by changing its opacity and then hide it by setting its display property to 'none'. The function
 *also allows for a custom duration and a callback function to be executed after the fade out animation is complete.
 *
 *Inputs:
 *- el: an HTML element to be faded out
 *- duration (optional): a number representing the duration of the fade out animation in milliseconds
 *- callback (optional): a function to be executed after the fade out animation is complete
 *
 *Flow:
 *1. Check if the input element exists and return if it doesn't
 *2. Check if the input element is already hidden and return if it is
 *3. Set the duration to a default value of 1000 milliseconds if it is not provided
 *4. Set the opacity of the element to 0
 *5. Set the transition property of the element to gradually change the opacity over the specified duration
 *6. Set the display property of the element to 'none' to hide it after the fade out animation is complete
 *7. Set a timeout to execute the callback function after the specified duration
 *
 *Outputs:
 *- None (void)
 *
 *Additional aspects:
 *- The function avoids errors for now but there is a TODO comment to throw an error in the future
 *- The function uses optional chaining (?.) to safely execute the callback function if it exists
 */

describe('fadeOut_function', () => {
  // Tests that the element fades out smoothly with default duration
  it('test_fades_out_with_default_duration', () => {
    const el = document.createElement('div');

    KeepTrack.getInstance().containerRoot.appendChild(el);
    fadeOut(el);
    jest.advanceTimersByTime(1000);
    expect(el.style.display).toBe('none');
  });

  // Tests that the element fades out smoothly with custom duration
  it('test_fades_out_with_custom_duration', () => {
    const el = document.createElement('div');

    KeepTrack.getInstance().containerRoot.appendChild(el);
    fadeOut(el, 2000);
    jest.advanceTimersByTime(2000);
    expect(el.style.display).toBe('none');
  });

  // Tests that the callback function is called after fade out animation
  it('test_callback_is_called_after_fade_out_animation', () => {
    const el = document.createElement('div');

    KeepTrack.getInstance().containerRoot.appendChild(el);
    const spy = jest.fn();

    fadeOut(el, 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(spy).toHaveBeenCalled();
  });

  // Tests that a missing element does not throw an error
  it('test_missing_element_does_not_throw_error', () => {
    expect(() => {
      fadeOut(null);
    }).not.toThrow();
  });

  // Skip if the element is not visible
  it.skip('test_element_not_visible', () => {
    const el = document.createElement('div');

    el.style.display = 'none';
    KeepTrack.getInstance().containerRoot.appendChild(el);
    const spy = jest.fn();

    fadeOut(el, 1000, spy);
    jest.advanceTimersByTime(1000);
    expect(spy).not.toHaveBeenCalled();
  });
});

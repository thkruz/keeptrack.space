import { LayersManager } from '@app/app/ui/layers-manager';
import { CelestrakColorScheme } from '@app/engine/rendering/color-schemes/celestrak-color-scheme';
import { GpAgeColorScheme } from '@app/engine/rendering/color-schemes/gp-age-color-scheme';
import { ObjectTypeColorScheme } from '@app/engine/rendering/color-schemes/object-type-color-scheme';
import { RcsColorScheme } from '@app/engine/rendering/color-schemes/rcs-color-scheme';
import { SmallSatColorScheme } from '@app/engine/rendering/color-schemes/smallsat-color-scheme';
import { StarlinkColorScheme } from '@app/engine/rendering/color-schemes/starlink-color-scheme';
import { SunlightColorScheme } from '@app/engine/rendering/color-schemes/sunlight-color-scheme';
import { VelocityColorScheme } from '@app/engine/rendering/color-schemes/velocity-color-scheme';
import { Container } from '../src/engine/core/container';
import { Singletons } from '../src/engine/core/interfaces';
import { defaultSensor } from './environment/apiMocks';
import { KeepTrack } from '@app/keeptrack';
// Generated by CodiumAI

/*
 *Code Analysis
 *
 *Main functionalities:
 *The LegendManager class is responsible for managing the legend menu and updating the legend colors based on the selected menu option. It contains a list of menu options and
 *corresponding HTML templates, as well as a list of CSS class selectors for legend items. The class provides methods for changing the legend menu, updating legend colors, and
 *setting velocity colors.
 *
 *Methods:
 *- change(menu: string): changes the legend menu to the specified option and updates the legend colors
 *- legendColorsChange(): updates the legend colors based on the current color scheme
 *- setColors_(): sets the background color of legend items based on the current color scheme
 *- setVelocityColor_(colorSchemeManagerInstance: ColorSchemeManager): sets the background color of velocity legend items
 *
 *Fields:
 *- legendClassList: a list of CSS class selectors for legend items
 *- menuOptions: a list of menu options and corresponding HTML templates
 */

describe('LegendManager_class_mobile', () => {
  const objectTypeFlags = {
    velocitySlow: false,
    velocityMed: false,
    velocityFast: false,
  };
  const colorSchemeManagerInstance = {
    resetObjectTypeFlags: jest.fn(),
    objectTypeFlags,
  };

  beforeEach(() => {
    settingsManager.isMobileModeEnabled = true;
    KeepTrack.getInstance().containerRoot.innerHTML = '';
    Container.getInstance().registerSingleton(Singletons.ColorSchemeManager, colorSchemeManagerInstance);
  });

  // Tests that the legend menu changes to a valid option
  it('test_change_valid_option', () => {
    const legendHoverDom = document.createElement('div');

    [
      GpAgeColorScheme, RcsColorScheme, ObjectTypeColorScheme, SunlightColorScheme,
      VelocityColorScheme, CelestrakColorScheme, StarlinkColorScheme, SmallSatColorScheme,
    ].forEach((ThisColorScheme) => {
      // Arrange
      const menu = ThisColorScheme.name;

      legendHoverDom.innerHTML = '';

      legendHoverDom.id = 'layers-hover-menu';
      KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

      // Act
      settingsManager.isMobileModeEnabled = true;
      LayersManager.change(menu);
      // Remove all styles from legendHoverDom.innerHTML
      legendHoverDom.innerHTML = legendHoverDom.innerHTML.replace(/style="[^"]*"/gu, '');

      // Assert
      expect(legendHoverDom.innerHTML).toEqual(ThisColorScheme.layersHtml);
    });
  });

  // Tests the behavior when the legend menu is cleared
  it('test_change_legend_menu_cleared', () => {
    const legendHoverDom = document.createElement('div');

    legendHoverDom.id = 'layers-hover-menu';
    KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

    LayersManager.change('clear');

    expect(legendHoverDom.style.display).toBe('none');
  });

  // Tests the behavior when a sensor is selected
  it('test_change_sensor_selected', () => {
    const legendHoverDom = document.createElement('div');

    legendHoverDom.id = 'layers-hover-menu';
    KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

    const catalogManagerInstance = {
      isSensorManagerLoaded: true,
    };
    const sensorManagerInstance = {
      currentSensors: [defaultSensor],
    };
    const colorSchemeManagerInstance = {
      resetObjectTypeFlags: jest.fn(),
    };

    Container.getInstance().get = jest.fn().mockImplementation((singleton) => {
      if (singleton === Singletons.CatalogManager) {
        return catalogManagerInstance;
      } else if (singleton === Singletons.SensorManager) {
        return sensorManagerInstance;
      } else if (singleton === Singletons.ColorSchemeManager) {
        return colorSchemeManagerInstance;
      }

      return null;
    });

    LayersManager.change(ObjectTypeColorScheme.name);

    expect(legendHoverDom.innerHTML).toBe(ObjectTypeColorScheme.layersHtml);
  });
});

describe('LegendManager_class_desktop', () => {
  const objectTypeFlags = {
    velocitySlow: false,
    velocityMed: false,
    velocityFast: false,
  };
  const colorSchemeManagerInstance = {
    resetObjectTypeFlags: jest.fn(),
    objectTypeFlags,
  };

  beforeEach(() => {
    settingsManager.isMobileModeEnabled = false;
    KeepTrack.getInstance().containerRoot.innerHTML = '';
    Container.getInstance().registerSingleton(Singletons.ColorSchemeManager, colorSchemeManagerInstance);
  });

  // Tests that the legend menu changes to a valid option
  it('test_change_valid_option', () => {
    const legendHoverDom = document.createElement('div');

    [
      GpAgeColorScheme, RcsColorScheme, ObjectTypeColorScheme, SunlightColorScheme,
      VelocityColorScheme, CelestrakColorScheme, StarlinkColorScheme, SmallSatColorScheme,
    ].forEach((ThisColorScheme) => {
      // Arrange
      const menu = ThisColorScheme.name;

      legendHoverDom.innerHTML = '';

      legendHoverDom.id = 'layers-hover-menu-popup';
      KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

      // Act
      LayersManager.change(menu);
      // Remove all styles from legendHoverDom.innerHTML
      legendHoverDom.innerHTML = legendHoverDom.innerHTML.replace(/style="[^"]*"/gu, '');

      // Assert
      expect(legendHoverDom.innerHTML).toEqual(ThisColorScheme.layersHtml);
    });
  });

  // Tests the behavior when the legend menu is cleared
  it('test_change_legend_menu_cleared', () => {
    const legendHoverDom = document.createElement('div');

    legendHoverDom.id = 'layers-hover-menu-popup';
    KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

    LayersManager.change('clear');

    expect(legendHoverDom.style.display).toBe('none');
  });

  // Tests the behavior when a sensor is selected
  it('test_change_sensor_selected', () => {
    const legendHoverDom = document.createElement('div');

    legendHoverDom.id = 'layers-hover-menu-popup';
    KeepTrack.getInstance().containerRoot?.appendChild(legendHoverDom);

    const catalogManagerInstance = {
      isSensorManagerLoaded: true,
    };
    const sensorManagerInstance = {
      currentSensors: [defaultSensor],
    };
    const colorSchemeManagerInstance = {
      resetObjectTypeFlags: jest.fn(),
    };

    Container.getInstance().get = jest.fn().mockImplementation((singleton) => {
      if (singleton === Singletons.CatalogManager) {
        return catalogManagerInstance;
      } else if (singleton === Singletons.SensorManager) {
        return sensorManagerInstance;
      } else if (singleton === Singletons.ColorSchemeManager) {
        return colorSchemeManagerInstance;
      }

      return null;
    });

    LayersManager.change(ObjectTypeColorScheme.name);

    expect(legendHoverDom.innerHTML).toBe(ObjectTypeColorScheme.layersHtml);
  });
});
